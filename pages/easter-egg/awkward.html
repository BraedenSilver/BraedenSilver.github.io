<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Oops, This Is Awkward — Braeden Silver</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta
      name="description"
      content="We couldn't find something to show you, so enjoy the Kilroys instead."
    />
    <meta property="og:title" content="Oops, This Is Awkward — Braeden Silver" />
    <meta
      property="og:description"
      content="A surprise page full of colorful Kilroys when the randomizer runs out of ideas."
    />
    <link rel="stylesheet" href="/assets/site.css" />
  </head>
  <body class="awkward-page" data-section="awkward">
    <div id="site-header">
      <noscript>
        <div class="noscript-banner" role="alert">
          JavaScript powers the interactive parts of this site. Please enable it
          to explore everything on BraedenSilver.com.
          <a href="/pages/help/enable-javascript/index.html">
            Learn how to turn on JavaScript.
          </a>
        </div>
      </noscript>
    </div>

    <main id="main-content">
      <nav class="page-back" aria-label="Back navigation">
        <a class="project-entry back-link" href="/index.html">
          <span class="back-link-icon" aria-hidden="true">←</span>
          <span class="back-link-label">Take me back home</span>
        </a>
      </nav>
      <h1>Oops, this is awkward.</h1>
      <p class="awkward-page__lead">
        Welcome to the Kilroy crew.
      </p>
      <div class="awkward-page__actions">
        <a href="/pages/blog/index.html">Browse the full blog</a>
        <a href="/pages/projects/index.html">Explore every project</a>
        <a href="/pages/research/index.html">Inspect all research notes</a>
      </div>
      <div
        class="awkward-killroy-field"
        id="awkward-killroy-field"
        aria-hidden="true"
      ></div>
    </main>

    <div id="site-footer">
      <noscript>
        <div class="noscript-banner" role="alert">
          JavaScript powers the interactive parts of this site. Please enable it
          to explore everything on BraedenSilver.com.
          <a href="/pages/help/enable-javascript/index.html">
            Learn how to turn on JavaScript.
          </a>
        </div>
      </noscript>
    </div>

    <script src="/js/site.js" defer></script>
    <script>
      (function () {
        const field = document.getElementById("awkward-killroy-field");
        if (!field) {
          return;
        }
        const total = 10;
        const RARE_FEATURE_CHANCE = 0.05;
        const fragment = document.createDocumentFragment();
        for (let i = 0; i < total; i += 1) {
          const el = document.createElement("div");
          const rareRoll = Math.random();
          const hasOracleEye = rareRoll < RARE_FEATURE_CHANCE;
          const hasCyclops =
            !hasOracleEye && rareRoll < RARE_FEATURE_CHANCE * 2;
          const hasClickableMouth =
            !hasOracleEye && !hasCyclops && rareRoll < RARE_FEATURE_CHANCE * 3;

          const classNames = ["awkward-killroy", "footer-eyes"];
          if (hasOracleEye) {
            classNames.push("awkward-killroy--oracle");
          }
          if (hasCyclops) {
            classNames.push("awkward-killroy--cyclops");
          }
          if (hasClickableMouth) {
            classNames.push("awkward-killroy--mouthy");
          }
          el.className = classNames.join(" ");

          const headParts = ['<div class="awkward-killroy__head">'];
          if (hasCyclops) {
            headParts.push(
              '  <div class="eye cyclops"><div class="pupil"></div></div>',
            );
          } else {
            headParts.push(
              '  <div class="eye left"><div class="pupil"></div></div>',
            );
            headParts.push(
              '  <div class="eye right"><div class="pupil"></div></div>',
            );
            if (hasOracleEye) {
              headParts.push(
                '  <div class="eye third"><div class="pupil"></div></div>',
              );
            }
          }
          if (hasClickableMouth) {
            headParts.push('  <div class="mouth"></div>');
          }
          headParts.push("</div>");
          el.innerHTML = headParts.join("");
          fragment.appendChild(el);
        }
        field.appendChild(fragment);

        function randomInRange(min, max) {
          return Math.random() * (max - min) + min;
        }

        function toHsl(hue, saturation, lightness) {
          return `hsl(${Math.round(hue)}deg ${saturation.toFixed(1)}% ${lightness.toFixed(1)}%)`;
        }

        const isCompactViewport =
          typeof window.matchMedia === "function"
            ? window.matchMedia("(max-width: 600px)").matches
            : false;

        requestAnimationFrame(() => {
          const fieldRect = field.getBoundingClientRect();
          const fieldWidth = Math.max(fieldRect.width, 1);
          const fieldHeight = Math.max(fieldRect.height, 1);
          const placements = [];
          const boundaryPadding = Math.max(
            12,
            Math.min(32, Math.min(fieldWidth, fieldHeight) * 0.08)
          );

          function findPosition(radius, spacing) {
            const minX = radius + boundaryPadding;
            const maxX = fieldWidth - radius - boundaryPadding;
            const minY = radius + boundaryPadding;
            const maxY = fieldHeight - radius - boundaryPadding;

            if (minX >= maxX || minY >= maxY) {
              return null;
            }

            const maxAttempts = 80;
            for (let attempt = 0; attempt < maxAttempts; attempt += 1) {
              const candidateX = randomInRange(minX, maxX);
              const candidateY = randomInRange(minY, maxY);

              const hasOverlap = placements.some((placed) => {
                const dx = placed.x - candidateX;
                const dy = placed.y - candidateY;
                const distance = Math.hypot(dx, dy);
                return distance < placed.radius + radius + spacing;
              });

              if (!hasOverlap) {
                return { x: candidateX, y: candidateY };
              }
            }

            return null;
          }

          const spacings = [28, 24, 20, 16, 12, 8];
          const FOOTER_PUPIL_RATIO = 12 / 28;

          field.querySelectorAll(".awkward-killroy").forEach((el) => {
            el.style.removeProperty("--awkward-border");
            el.style.removeProperty("--awkward-shadow");
            el.style.removeProperty("--awkward-pupil");
            el.style.removeProperty("--pupil-size");

            const hue = randomInRange(0, 360);
            const saturation = randomInRange(62, 88);
            const lightness = randomInRange(56, 78);

            const minSize = isCompactViewport ? 102 : 120;
            const maxSize = isCompactViewport ? 148 : 176;
            const maxDimension = Math.max(
              0,
              Math.min(fieldWidth, fieldHeight) - boundaryPadding * 2
            );
            const sizeUpperBound =
              maxDimension > 0
                ? Math.max(minSize, Math.min(maxSize, maxDimension))
                : minSize;
            const initialLowerBound = Math.min(minSize, sizeUpperBound);
            let size = randomInRange(initialLowerBound, sizeUpperBound);
            const rotate = randomInRange(-7, 7);
            const eyeOffsetFactor = randomInRange(0.19, 0.22);
            const eyeTopFactor = randomInRange(0.32, 0.36);
            const eyeSizeFactor = randomInRange(0.22, 0.25);

            const absoluteMinSize = Math.min(
              sizeUpperBound,
              Math.max(72, minSize * 0.75)
            );

            const radius = () => size / 2;
            let position = null;

            for (const spacing of spacings) {
              position = findPosition(radius(), spacing);
              if (position) {
                break;
              }
              if (size > absoluteMinSize) {
                size = Math.max(absoluteMinSize, size * 0.92);
              }
            }

            if (!position) {
              position = findPosition(radius(), 0);
            }

            if (!position && size > absoluteMinSize) {
              size = absoluteMinSize;
              position = findPosition(radius(), 0);
            }

            if (!position) {
              position = { x: fieldWidth / 2, y: fieldHeight / 2 };
            }

            const finalSize = size;
            const eyeOffset = Math.round(finalSize * eyeOffsetFactor);
            const eyeTop = Math.round(finalSize * eyeTopFactor);
            const eyeSize = Math.round(finalSize * eyeSizeFactor);
            const outlineWidth = 2.5;
            const pupilSize = Math.round(eyeSize * FOOTER_PUPIL_RATIO);
            const shadowOffset = Math.min(8, Math.max(4, Math.round(finalSize * 0.035)));

            const finalRadius = finalSize / 2;
            placements.push({ x: position.x, y: position.y, radius: finalRadius });

            const xPercent = (position.x / fieldWidth) * 100;
            const yPercent = (position.y / fieldHeight) * 100;

            el.style.setProperty("--awkward-skin", toHsl(hue, saturation, lightness));
            el.style.setProperty("--awkward-sclera", "#fff");
            el.style.setProperty("--killroy-x", `${xPercent.toFixed(2)}%`);
            el.style.setProperty("--killroy-y", `${yPercent.toFixed(2)}%`);
            el.style.setProperty("--killroy-rotate", `${rotate.toFixed(1)}deg`);
            el.style.setProperty("--awkward-size", `${finalSize.toFixed(0)}px`);
            el.style.setProperty("--eye-offset", `${eyeOffset}px`);
            el.style.setProperty("--eye-top", `${eyeTop}px`);
            el.style.setProperty("--eye-size", `${eyeSize}px`);
            el.style.setProperty("--pupil-size", `${pupilSize}px`);
            el.style.setProperty("--eye-border", `${outlineWidth}px`);
            el.style.setProperty("--awkward-border-width", `${outlineWidth}px`);
            el.style.setProperty("--awkward-shadow-offset", `${shadowOffset}px`);

            if (el.classList.contains("awkward-killroy--oracle")) {
              const thirdEye = el.querySelector(".eye.third");
              if (thirdEye) {
                const thirdEyeSizeFactor = randomInRange(0.16, 0.2);
                const thirdEyeSize = Math.round(finalSize * thirdEyeSizeFactor);
                const thirdEyeVerticalOffset = Math.round(
                  thirdEyeSize * randomInRange(0.55, 0.68),
                );
                const thirdEyeTop = Math.max(
                  outlineWidth * 2,
                  eyeTop - thirdEyeVerticalOffset,
                );
                const thirdEyePupilSize = Math.round(
                  thirdEyeSize * FOOTER_PUPIL_RATIO,
                );
                thirdEye.style.setProperty("--eye-size", `${thirdEyeSize}px`);
                thirdEye.style.setProperty("--eye-top", `${thirdEyeTop}px`);
                thirdEye.style.setProperty(
                  "--pupil-size",
                  `${thirdEyePupilSize}px`,
                );
              }
            }

            if (el.classList.contains("awkward-killroy--mouthy")) {
              const mouthSizeFactor = randomInRange(0.18, 0.24);
              const mouthTopFactor = randomInRange(0.6, 0.7);
              const mouthSize = Math.round(finalSize * mouthSizeFactor);
              const mouthTop = Math.round(finalSize * mouthTopFactor);
              const mouthLineWidth = Math.max(
                2,
                Math.round(outlineWidth * 1.25),
              );
              el.style.setProperty("--mouth-size", `${mouthSize}px`);
              el.style.setProperty("--mouth-top", `${mouthTop}px`);
              el.style.setProperty(
                "--mouth-line-width",
                `${mouthLineWidth}px`,
              );
              el.style.setProperty(
                "--mouth-color",
                "var(--color-kilroy-border)",
              );
            }
          });
        });

        const BLINK_MIN_DELAY_MS = 2800;
        const BLINK_MAX_DELAY_MS = 6400;
        // Match the footer wink timing so the blink looks identical.
        const BLINK_DURATION_MS = 1500;
        // Periodically toggle the same `.wink` class the footer uses.
        // Keep track of the timers that trigger each Kilroy's blinks.
        const killroyBlinkCleanup = new WeakMap();

        function startKillroyBlinking(killroy) {
          if (killroyBlinkCleanup.has(killroy)) {
            return;
          }

          const eyes = Array.from(killroy.querySelectorAll(".eye"));
          if (!eyes.length) {
            return;
          }

          // Hold the pending timeout so we can cancel or reschedule it.
          let blinkTimeoutId = null;

          function clearPendingBlink() {
            if (blinkTimeoutId !== null) {
              window.clearTimeout(blinkTimeoutId);
              blinkTimeoutId = null;
            }
          }

          function scheduleNextBlink() {
            if (!killroyBlinkCleanup.has(killroy)) {
              return;
            }
            // Randomize the next blink to keep the timing organic.
            const delay =
              BLINK_MIN_DELAY_MS +
              Math.random() * (BLINK_MAX_DELAY_MS - BLINK_MIN_DELAY_MS);
            clearPendingBlink();
            // Kick off the blink after waiting for the chosen delay.
            blinkTimeoutId = window.setTimeout(runBlink, delay);
          }

          function runBlink() {
            blinkTimeoutId = null;
            if (!killroyBlinkCleanup.has(killroy)) {
              return;
            }
            if (!killroy.isConnected) {
              return;
            }

            // Toggle the wink class on every eye to mirror the footer animation.
            eyes.forEach((eye) => {
              if (eye.classList.contains("wink")) {
                return;
              }
              eye.classList.add("wink");
              window.setTimeout(() => {
                eye.classList.remove("wink");
              }, BLINK_DURATION_MS);
            });

            scheduleNextBlink();
          }

          const cleanup = () => {
            clearPendingBlink();
            // Ensure any partially blinked eyes pop back open.
            eyes.forEach((eye) => eye.classList.remove("wink"));
          };

          killroyBlinkCleanup.set(killroy, cleanup);
          scheduleNextBlink();
        }

        function stopKillroyBlinking(killroy) {
          const cleanup = killroyBlinkCleanup.get(killroy);
          if (cleanup) {
            cleanup();
            killroyBlinkCleanup.delete(killroy);
          }
        }

        const reduceMotionQuery =
          typeof window.matchMedia === "function"
            ? window.matchMedia("(prefers-reduced-motion: reduce)")
            : null;

        const killroys = Array.from(field.querySelectorAll(".awkward-killroy"));
        if (!killroys.length) {
          return;
        }

        const isDocumentVisible = () =>
          typeof document.visibilityState === "string"
            ? document.visibilityState === "visible"
            : true;

        const enableBlinking = () => {
          killroys.forEach((killroy) => startKillroyBlinking(killroy));
        };

        const disableBlinking = () => {
          killroys.forEach((killroy) => stopKillroyBlinking(killroy));
        };

        if ((!reduceMotionQuery || !reduceMotionQuery.matches) && isDocumentVisible()) {
          enableBlinking();
        }

        const handleVisibilityChange = () => {
          if (!isDocumentVisible()) {
            disableBlinking();
          } else if (!reduceMotionQuery || !reduceMotionQuery.matches) {
            enableBlinking();
          }
        };

        document.addEventListener("visibilitychange", handleVisibilityChange);

        if (reduceMotionQuery) {
          const handleReduceMotionChange = (event) => {
            if (event.matches) {
              disableBlinking();
            } else if (isDocumentVisible()) {
              enableBlinking();
            }
          };

          if (typeof reduceMotionQuery.addEventListener === "function") {
            reduceMotionQuery.addEventListener("change", handleReduceMotionChange);
          } else if (typeof reduceMotionQuery.addListener === "function") {
            reduceMotionQuery.addListener(handleReduceMotionChange);
          }
        }
      })();
    </script>
  </body>
</html>
